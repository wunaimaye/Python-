--------------------Python面向对象--------------------
	一、基本理论：
		{1}什么是对象：
			[1]万物皆对象
			[2]对象是具体物体：
				（1）属性
				（2）行为
				（3）把很多零散的东西封装成为一个整体
			[3]Python中的体现：Python是一门特别彻底的面向对象编程(OOP)的语言
				（1）其他语言：
					1、基本数据类型：int、float、bool...	
					2、对象类型：String("xxx")、Array([1, 2, 3])...
				（2）Python：
					对象类型(每个类型都为一个对象)：int、float、bool、list...
		{2}面向过程&面向对象：
			[1]都是一种解决问题的思路
			[2]面向过程：在解决问题的时候，关注的是解决问题的每一个过程
			[3]面向对象：在解决问题的时候，关注的是解决问题所需的对象
			[4]对比：
				（1）面向过程和面向对象都是一种解决问题的方法
				（2）面向过程编程最重要的是：
					1、按照步骤划分
					2、把一个任务分成具体到每一个步骤
				（3）面向对象编程最重要的是：
					1、按照功能对象进行划分
					2、找到对象，按照确定对象的属性和行为
				（4）如何从面向过程编程的思想，过渡到面向对象编程：
					1、一样的，列举出一个任务的具体实现步骤
					2、试图分离这些实现步骤中的功能代码块
					3、将这些功能代码块，划分到某一个对象中
					4、根据这个对象以及对应的行为，抽象出对应的类：设计类
		{3}类：
			[1]什么是类：
				（1）某一个具体对象特征的抽象
				（2）例如：
					1、张三 这个具体的人：属性：年龄18，体重180...；行为：吃、喝、嫖、赌
					2、抽象出来的类：不良青年：属性：...；行为：...
			[2]类的作用：
				（1）根据抽象的类，产生的具对象
				（2）例如：
					1、类：不良青年：属性：...；行为：...
					2、对象：张三、李四、王五...
			[3]类的组成：
				（1）名称
				（2）属性
				（3）方法
				（4）一定要注意：以上属性和方法都是抽象概念，在产生对象之后，对象才拥有具体的属性值和方法实现
			[4]举例生活中的类：
				（1）钱(类)：(对象)一毛、五毛、一块...
				（2）汽车(类)：(对象)宝马、红旗...
			[5]对象和类的关系：对象->抽象->类->实例化->对象

	二、面向对象在Python中的实践：
		{1}定义一个类：
			class Complex:
			    pass(pass代表空语句)
		{2}通过类创建出一个对象：Complex()
		{3}属性相关：
			[1]属性和变量的区别及判定依据：
				（1）区别：
					1、概念：变量是"可以改变的量值"；属性是"属于某个对象的特性"
					2、访问权限：变量：根据不同的位置，存在不同的访问权限(全局变量、局部变量...)；属性：只能通过对象来进行访问：所以必须先找到对象；对象也是通过变量名来引用；而既然是变量，也有对应的访问权限
				（2）判定依据：是否存在宿主
			[2]对象属性：
				（1）怎样让一个对象拥有一些属性(增)：
					1、直接通过对象，动态添加：语法：对象.属性 = 值
					2、通过类的初始化方法(构造方法)：__init__方法
				（2）怎样访问一个对象的属性(查)：代码自查
				（3）怎样修改一个对象的属性(改)：代码自查
				（4）怎样删除一个对象的属性(删)：代码自查
				（5）补充：
					访问所有的属性：对象.__dict__
			[3]类属性：万物皆对象，类也是一个对象
				（1）怎样让一个类拥有属性(增)：
					1、方法一：类名.类属性 = 值
					2、方法二：
						class Dog:
						    dogcount = 10
				（2）怎样查询一个类的属性(查)：
					1、通过类访问：类名.类属性
					2、通过对象访问：对象.类属性
					3、注意：可以通过对象访问到类属性的原因：和Python对象的属性查找机制有关：先优先到对象自身去查找属性，找到则结束；如果没找到，则根据__class__找到对象对应的类，到这个类里面查找
				（3）怎样修改一个类的属性(改)：通过类名修改，若通过对象修改则是修改对象的属性
				（4）怎样删除一个类的属性(删)：通过类名删除：del 类名.属性；不能通过对象删除，del语句只能删除直系属性
				（5）注意：
					1、类属性的内存存储问题：
						A、一般情况下，属性存储在__dict__的字典当中，有些内置对象没有这个__dict__属性
						B、一般对象可以直接修改__dict__属性
						C、但类对象的__dict__为只读；默认无法修改，可以通过setattr方法修改
					2、类属性被各个对象共享
				（6）补充：查看一个类的所有属性：类名.__dict__
			[4]对象属性和类属性之间的区别联系：参考之前的对象与类的查询机制
			[5]高级：限制对象添加属性用__slots__：
						class Person:
						    __slots__ = ["属性名"]
		{4}方法相关：
			[1]方法的概念：
				（1）描述一个目标的行为动作：比如描述一个人怎样吃，怎样喝，怎样玩...
				（2）和函数非常相似：
					1、都封装了一系列行为动作
					2、都可以被调用之后，执行一系列行为动作
					3、最主要的区别就是：调用方式
			[2]方法的划分：(按实例化来说，将对象称为实例，类称为类；按本质来说，将对象称为对象，类称为类或类对象）
				（1）实例方法：默认第一个参数需要接收到一个实例
				（2）类方法：默认第一个参数需要接收到一个类
				（3）静态方法：静静地看着前面俩装逼，第一个参数啥也不默认接收
				（4）注意：
					1、划分的依据是：方法的第一个参数必须要接收的数据类型
					2、不管是哪一种类型的方法，都是从存储在类当中；没有在实例当中的
					3、不同类型方法的调用方式不同：但不管怎么调，把握一个原则：不管是自己传递，还是还是解释器帮我们处理；最终要保证不同类型的第一个参数接收到的数据，是他们想要的类型
				（5）使用：
					1、语法
					2、不同类型的方法的规则
					3、不同类型方法的调用
					4、根据不同的问题，自己决定，到底该设计怎样的方法来解决问题
			[3]实例方法：
				（1）class Person:
					    def run(self):
					        pass
				（2）标准调用：
					1、使用实例调用实例方法：不用手动传，解释器会自动把调用对象本身传递过去
					2、注意：如果实例方法没有接收任何参数，则会报错：一个自动传，一个不接收
				（3）其他调用：
					1、使用类调用
					2、间接调用
					3、以上两个本质就是直接找到函数本身来调用，真正使用时还是建议使用标准调用
			[4]类方法：
				（1）class Person:
					    @classmethod#装饰器的作用：在保证原本函数不改变的前提下，直接给这个函数增加一些功能
					    def leifangfa(cls, a，...):
						pass
				（2）标准调用：
					1、使用类调用类方法：不用手动传，解释器会自动把调用对象本身传递过去
					2、注意：如果类方法没有接收任何参数，则会报错：一个自动传，一个不接收
				（3）其他调用：
					1、实例调用(会自动忽略实例而去找它对应的类)
					2、间接调用(与实例调用一样)
					3、本质上与类调用相同

			[5]静态方法：
				（1）class Person:
					    @staticmethod
					    def jingtai(a, b, ...):
						pass
				（2）调用：不用传任何对象给第一个对象，只需要手段输入实参就行了
			[6]补充：不同类型的方法访问不同类型的属性
				（1）通过实例方法来访问各属性：可以通过实例方法访问类属性和实例属性,但是当实例中有与类相同的属性时，访问的时实力的属性
				（2）通过类方法来访问各属性：可以通过类方法访问类属性，但是不能通过类方法访问实例属性
				（3）通过静态方法来访问各属性：通过静态方法访问各属性，但是不通过第一个参数.属性来访问了，因为静态方法不传参数，所以必须精确到类/实例.属性
		{5}补充：
			[1]类相关补充：
				（1）元类：
					1、概念：
						A、对象的产生：由类创建出来的
						B、类也是对象
						C、类对象是由另一个类：
						D、大致结构：元类实例化出类对象，然后类对象实例化出实例
					2、类对象的创建方式以及创建流程：
						A、创建方式：
							a、直接用class 类名来创建
							b、用type函数来创建
						B、创建流程：
							a、检测类中是否有明确__metaclass__属性
							b、检测父类中是否存在__metaclass__属性
							c、检测模块中是否存在__metaclass__属性
							d、通过内置的type这个元类来创建这个类对象
					3、元类的应用场景：
						A、拦截类的创建
						B、修改类
						C、返回修改之后的类
						D、后面补充
				（2）类的描述：
					1、目的：方便理清逻辑思路；方便多人合作开发时的沟通；方便生成项目文档
					2、描述方式：用"""..."""，而且注释不论是对类还是对方法等，都要在开头就注释
					3、生成项目文档(补充)：
						A、方式一：使用内置模块pydoc；具体步骤：
							a、查看文档描述：python3-m pydoc 模块名称
							b、启动本地服务器，浏览文档：python3-m pydoc-p 1234
							c、生成指定模块html文档：python3-m pydoc-w 模块名称
						B、方式二：
							a、使用第三方模块：1）Sphinx；2）epydoc；3）doxygen
							b、具体步骤：目前感兴趣可以自己先研究后续讲”包和模块“之后会进行补充
			[2]属性相关补充：
				（1）私有化属性：
					1、概念：
					2、意义：
					3、注意：Python并没有真正的私有化支持，但是，可以使用下划线完成伪私有的效果；类属性(方法)和实例属性(方法)遵循相同的规则
					4、x(无下划线):公有属性：
						A、类内部访问√
						B、子类内部访问√
						C、模块内其他位置访问√：
							a、类访问：1）父类；2）派生类
							b、实例访问：1）父类实例；2）派生类实例
						D、跨模块访问(即跨文件访问)√：
							a、import形式导入
							b、from 模块 import*形式导入
					5、_y(一个下划线):受保护属性：
						A、类内部访问√
						B、子类内部访问√
						C、模块内其他位置访问！：
							a、类访问：1）父类；2）派生类
							b、实例访问：1）父类实例；2）派生类实例
						D、跨模块访问(即跨文件访问)：
							a、import形式导入！
							b、from 模块 import*形式导入：1）有__all__指明对应变量：__all__ = ["变量"]√；2）没有__all__指明对应变量×
					6、__z(两个下划线):
						A、私有属性：
							a、类内部访问√
							b、子类内部访问×
							c、模块内其他位置访问×：
								1】类访问：父类；派生类
								2】实例访问：父类实例；派生类实例
							d、跨模块访问√!×：参照但单下划线开头变量的访问原则
						B、私有属性的实现机制：
							a、名字重整：重改__z为另一个名称如：__类名__z
							b、目的：防止外界直接访问；防止被子类同名成属性覆盖
						C、应用场景：
							a、数据保护
							b、数据过滤
					7、补充：
						A、xxx_：用于与系统内置的一些关键字做区分，比如我想创建一个class名称的变量，但是class是内置关键字，则用class_来区分
						B、__xx__：一般都是用于表示一些内置关键字如__dict__等等
				（2）只读属性：
					1、概念：一个属性(一般指实例属性)，只能读取，不能写入
					2、应用场景：有些属性，只限在内部根据不同场景进行修改，而对外界来说，不能修改，只能读取；如：电脑类的网速属性，网络状态属性
					3、方式一：
						A、方案：
							a、全部隐藏：私有化：既不能读，也不能写
							b、部分公开：公开读的操作
						B、具体实现：
							a、私有化：通过"属性前置双下划线"实现
							b、部分公开：
								1】通过公开的方式
								2】优化：使用装饰器@property：
									1）作用：将一些"属性的操作方法"关联到某一个属性中
									2）概念补充：
										1>经典类：没有继承(object)
										2>新式类：继承(object)
										3>Python2.x版本定义一个类时，默认不继承(object)
										4>Python3.x版本定义一个类时，默认继承(object)
										5>建议使用：新式类
									3）property
					4、方式二：
						A、类内定义__setattr__(self, key, value):实例方法，当我们通过" 实例.属性 = 值 "，给一个实例增加一个属性，或者说，修改一下属性值的时候，都会调用这个方法
						B、在这个方法的内部，我们自行定义条件语句来判断哪些是只读属性，哪些是可读写属性，然后将它们给存储到__dict__字典里，如判断只读属性age：if key == "age" and key in self.__dict__.keys()
						C、当不是只读属性时，则将其直接存入该实例的字典中，如：else:
												    self.__dict__[key] = value
						D、注意，存入字典一定要这样，如果直接赋值如：self.key = value，这会进入死循环，一直调用__setattr__(self, key, value):这个方法
				（3）内置特殊属性：
					1、类属性：
						A、__dict__：类的属性
						B、__bases__：类的所有父类构成元组
						C、__doc__：类的文档字符串
						D、__name__：类名
						E、__module__：类定义所在的模块
					2、实例属性：
						A、__dict__：实例的属性
						B、__class__：实例对应的类
			[3]方法相关补充：
				（1）私有化方法
				（2）内置特殊方法：
					1、生命周期方法(下一小节单独介绍)
					2、其他内置方法：
						A、信息格式化操作：
							a、__str__方法：面向用户
							b、__repr__方法：面向开发人员
						B、调用操作(__call__方法)：
							a、作用：使得"对象"具备当作函数来调用的能力
							b、使用：
								class Person:
								    def __call__(self, *args, **kwargs):
								        print("xxx", args, kwargs)

								p = Person()
								p()# 让实例像这样如函数被调用，只需要在类里面定义一个__call__():实例方法即可，在使用这种调用方法时，解释器会自动去类里面找__call__()方法
							c、应用场景：具体看代码篇
							d、案例：
						C、索引操作：
							a、作用：可以对一个实例对象进行索引
							b、步骤：
								1】实现三个内置方法：
									1）__setitem__(self, key, value)：增或改实现方法
									2）__getitem__(self, item)：查实现方法
									3）__delitem__(self, key)：删实现方法
								2】可以以索引的形式操作对象：
									1）增/改：p[1] = 666;  p["name"] = "sz"
									2）查：p[1];  p["name"]
									3）删：del p[1];  del p["name"]
						D、切片操作：
							a、作用：可以对一个实例对象进行切片操作
							b、步骤：
								1】(×3.几版本无法使用)Python2.x版本：已经过期，不列举了
								2】Python3.x版本：同意由"索引操作"进行管理：
									1）__setitem__(self, key, value)：
									2）__getitem__(self, item)：
									3）__delitem__(self, key)：
						E、计较操作：
							a、作用：可以自定义对象"比较大小，相等以及真假"规则
							b、步骤：
								1】==：__eq__
								2】!=：__ne__
								3】<：__lt__
								4】<=：__le__
								5】>：__gt__
								6】>=：__ge__
							c、注意：如果对于反向操作的比较符，只定义了其中一个方法，但使用的是另一种比较运算，那么，解释器会采用调换参数的方式进行调用该方法；但不支持叠加操作
							d、补充：
								1】使用装饰器，自动生成"反向"，"组合"的方法
								2】上下文环境中的布尔值：__bool__
						F、遍历操作(迭代器)：
							a、怎样让我们自己创建的对象可以使用for in 进行遍历：
								1】实现__getitem__方法
								2】实现__iter__方法
							b、怎样让我们自己创建的对象可以使用next函数进行访问：
							c、补充：可迭代对象必须有__iter__方法，而迭代器必须同时得有__iter__和__next__方法方法
						G、描述器：
							a、概念：可以描述一个属性操作的对象：
								1】对象
								2】属性的操作：增/改/删/查
								3】描述
							b、作用：
							c、定义：
								1】定义方式1：property
								2】定义方式2：将描述器所具备的三个方法__set__、__get__、__delete__单独定义到一个类中，再将该类付给另一给类中的属性，如：
									class Age:
									    def __get__(self, instance, owner):
									        print("运行get")

									    def __set__(self, instance, value):
									        print("运行set")

									    def __delete__(self, instance):
									        print("运行delete")

									class Person:
									    age = Age()

									p = Person()

									p.age = 19
									print(p.age)
									del p.age
							d、调用细节：
								1】调用描述器都是使用实例来进行调用，不用类进行调用
								2】不能够顺利转换的场景：
									1）新式类和方法类
									2）方法拦截：
										1>一个实例属性的正常访问顺序：
											1》实例对象自身的__dict__字典
											2》对应类对象的__dict__字典
											3》如果有父类，会再往上层的__dict__字典中检测
											4》如果没找到，有定义了__getattr__方法，就会调用这个方法
										2>而在上述的整个过程当中，如何将描述器的__get__方法给嵌入到查找机制中？
											1》就是通过__getattribute__方法实现的；
											2》内部模拟为：如果实现了描述器方法__get__就会直接调用；如果没有，则按照上面的查找机制去查找
							e、注意：描述器只在新式类中有效；值的存储问题(看代码篇)
						H、装饰器(看代码篇)：注意装饰器嵌套时，根据逻辑看哪个装饰器功能先执行，就把哪个装饰器放前面
	三、Python对象的生命周期，以及周期方法：
		{1}概念：生命周期：
			[1]指的是一个对象，从诞生到消亡的过程
			[2]当一个对象被创建时，会在内存中分配相应的内存空间进行存储
			[3]当这个对象不再使用，为了节约内存，就会把这个对象释放
		{2}涉及问题：
			[1]如何监听一个对象的生命过程？
			[2]Python是如何掌控一个对象的生命？
		{3}监听对象生命周期：
			[1]__new__方法：
				（1）当我们创建一个对象时，用于给这个对象分配内存的方法
				（2）通过拦截这个方法，可以修改对象的创建过程，比如：单例设计模式
			[2]__init__方法：
			[3]__del__方法：
		{4}内存管理机制：
			[1]存储方面：
				（1）在Python中万物皆对象：
					1、不存在基本数据类型
					2、0，1.2，True，False，"abc"这些全部都是对象
				（2）所有对象都会在内存中开辟一块空间进行存储：
					1、会根据不同的类型及内容，开辟不同的空间大小进行存储
					2、返回该空间的地址给外界接收(称为"引用")，用于后续对这个对象的操作：
						A、可通过id()函数获取内存地址(10进制)
						B、通过hex()函数可以查看对应的16进制地址
				（3）对于整数和短小的字符，Python会进行缓存；不会创建多个相同的对象
				（4）容器对象，存储的其他对象，仅仅是其他对象的引用，并不是其他对象本身
			[2]垃圾回收方面：
				（1）引用计数器：
					1、概念：
						A、一个对象，会记录着自身被引用的个数
						B、每增加一个引用，这个对象的引用计数会自动+1
						C、每减少一个引用，这个对象的引用计数会自动-1
					2、举例：
						A、引用计数+1场景：
							a、对象被创建：p1 = Person()
							b、对象被引用：p2 = p1
							c、对象被作为参数，传入到一个函数中：
							d、对象作为一个元素，存储在容器中：I = [p1]
						B、引用计数-1场景：
							a、对象的别名被显示销毁：del p1
							b、对象的别名被赋予新的对象：p1 = 123
							c、一个对象离开他的作用域：一个函数执行完毕时，内部的局部变量关联的对象，它的引用会被释放
							d、对象所在的容器被销毁，或从容器中删除对象
					3、查看引用计数：
						A、import sys
						B、sys.getrefcount(对象)：注意会大一
				（2）垃圾回收：
					1、主要作用：从经历过"引用计数器机制"仍未被释放的对象中，找到"循环引用"，干掉相关对象
					2、底层机制(底层&难)：
						A、怎样找到"循环引用"：
							a、收集所有的"容器对象"，通过一个双链表进行引用：
								1】容器对象：可以引用其他对象的对象：列表、元组、字典、自定义类对象...
								2】非容器对象：
							b、针对每一个"容器对象"，通过一个变量gc_refs来记录当前对应的引用计数
							c、对于每个"容器对象"，找到它引用的"容器对象"，并将这个"容器对象"的引用计数-1
							d、经过步骤3以后，如果一个"容器对象"的引用计数为0，就代表这玩意可以被回收了，肯定是"循环引用"导致它活到现在的
						B、如何提升查找"循环引用"的性能：
							a、如果程序中创建了很多个对象，而针对每一个对象都要参与"检测"过程；则会非常耗费性能
							b、所以，基于这个问题，产生了一种假设：
								1】越命大的对象，越长寿
								2】假设一个对象10次检测都没有给它干掉，那么认定这个对象一点很长寿，就会减少这货的"检测频率"
							c、基于这种假设，设计了一套机制：分代回收：
								1】机制：
									1）默认一个对象被创建出来后，属于0代
									2）如果经历过这一代"垃圾回收"后，依然存活，则划分到下一代
									3）"垃圾回收"的周期顺序为：
										1>0代"垃圾回收"一定次数，会触发0代和1代回收
										2>1代"垃圾回收"一定次数，会触发0代、1代和2代回收
								2】查看和设置相关参数：
									1）import gc
									2）print(gc.get_threshould())
									3）gc.set_threshould(700, 10, 5)
								3】垃圾回收器当中，新增的对象的个数-消亡的的对象的个数，达到一定阈值时，才会触发垃圾检测
					3、垃圾回收时机(掌握&简单)：
						A、自动回收：触发条件：开启垃圾回收机制:
							a、gc.enable()：开启垃圾回收机制(默认开启)
							b、gc.disable()：关闭垃圾回收机制
							c、gc.isenable()：判定是否开启
							并且达到垃圾回收的阈值：
							a、垃圾回收器中，新增的对象个数和释放的对象的个数之差达到某个阈值
							b、涉及方法：
								1】gc.get_threshold()：获取自动回收阈值
								2】gc.set_threshold()：设置自动回收阈值
						B、手动回收
				（3）特殊场景：...
			[3]测量对象的引用个数：...
	四、面向对象编程-综合案例：看代码篇
	五、面向对象三大特性：
		{1}封装：
			[1]概念：将一些属性和相关方法封装在一个对象中，对外隐藏内部具体实现细节：
				（1）内部实现，外界不需要关心
				（2）外界只需要根据"内部提供的接口"去使用就行
			[2]好处：
				（1）使用起来更加方便：
					1、因为已经把很多相关功能，封装成一个整体
					2、类似于向外界提供一个工具箱
					3、针对于不同场景，使用不同的工具箱就可以
				（2）保证数据的安全：
					1、针对于安全级别高的数据，可以设置为"私有"
					2、可以控制数据为只读：外界无法修改
					3、也可以拦截数据的写操作：进行数据校验和过滤
				（3）利于代码维护：
					1、如果后期功能代码需要维护，则直接修改这个类内部代码即可
					2、只要保证接口名称不变；外界不需要做任何代码修改
		{2}继承：
			[1]概念：
				（1）现实中的"继承"：子女继承父母的财产资源
				（2）编程中的"继承"：
					1、一个类"拥有"另一个类的"资源"的方式之一
					2、"拥有"：并不是资源的复制，而是资源的"使用权"
					3、"资源"：指"非私有的"属性和方法
				（3）Dog类继承Animal类
			[2]目的：
			[3]分类：
				（1）单继承：
					1、概念：仅仅继承了一个父类
					2、语法：
						class Animal:
						    pass

						class Dog(Animal):
						    """
						    单继承
						    """
						    pass
				（2）多继承：
					1、概念：继承了多个父类
					2、语法：
						class Animal:
						    pass

						class Dog:
						    pass

						class xxx(Animal, Dog):
						    """
						    多继承
						    """
						    pass
			[4]type和object的区别：type元类创建所有的类对象，object也是由type创建的类对象；而所有的类又都继承object，type也继承object
			[5]继承下的影响：
				（1）资源的继承：
					1、明确：在python中，继承是指资源的使用权，所以，测试某个资源能否被继承，其实就是测试在子类当中，能不能访问到父类当中的这个资源
					2、结论：除下私有属性和私有方法，其它的基本都能继承：
						A、公有属性/方法
						B、受保护属性/方法
						C、内置方法
				（2）资源的使用：
					1、继承的几种形态：
						A、单继承链
						B、无重叠的多继承链
						C、有重叠的多继承链
					2、几种形态应该遵循的标准化原则：
						A、单继承：先往父类里查找，没有再向上查找，即单调向上
						B、无重叠的多继承：先对一条链按照单调向上查找，没有再对另一条链按照单调向上查找，即深度优先，先左后右链
						C、有重叠的多继承：类似于上面的无重叠，先左后右，最后重叠
					3、针对于几种标准原则的方案演化：
						A、Python2.2之前：
							a、仅仅存在经典类
							b、MRO原则：深度优先(从左到右)
							c、问题："有重叠的多继承"中，违背"重写可用原则"
						B、Python2.2：
							a、产生了新式类
							b、MRO原则：
								1】经典类：深度优先(从左到右)
								2】新式类：在深度优先(从左到右)的基础上，优化了一部分：如果产生重复元素，会保留最后一个，并且，更尊重基类的先后顺序
								3】注意：并不是"广度优先算法"
							c、问题：
								1】无法检测出有问题的继承
								2】有可能还会违背"局部有先"的原则
								3】例如：
									1）图示：
										object
										    ^
										    |
										    D
										    ^
										    |
										    B <----
										    ^        |
										    |        |
										    |       C
										    |        |
										    |        |
										    A------
									2）按照"上述算法"计算结果为：A -> C -> B -> D -> object，但问题是：A继承(B, C)
						C、Python2.3-2.7：
							a、新式类经典类并存
							b、MRO原则：
								1】经典类：深度优先(从左到右)
								2】新式类：C3算法
						D、Python3.x之后：MRO原则：新式类：C3算法
						E、概念补充：
							a、MRO：Method resolution Order 方法解析顺序
							b、深度优先：
								1】沿着一个继承链，尽可能的往深了去找
								2】集体算法步骤：
									1）把根节点压入栈中
									2）每次从栈中弹出一个元素，搜索所有在它下一级的元素，把这些元素压入栈中：发现已经被处理，则略过
									3）重复第二个步骤到结束为止
							c、广度优先：
								1】沿着继承链，尽可能的往宽了去找
								2】集体算法步骤：
									1）把根节点放到队列末尾
									2）每次从队列的头部取出一个元素，查看这个元素所有的下一级元素，把它们放到队列的末尾：发现已经被处理，则略过
									3）重复上面步骤
							d、C3算法：
								1】真正步骤：
									1）两个公式：
										1>L(object) = [object]
										2>L(子类(父类1, 父类2)) = [子类] + merge(L(父类1), L(父类2), [父类1, 父类2])
									2）注意：
										1>+代表合并列表
										2>merge算法：
											1》第一个列表的第一个元素：是后续列表的对一个元素或者后续列表中没有再次出现，则将这个元素合并到最终的解析列表中并从当前操作的所有列表中删除
											2》如果不符合，则跳过此元素，查找下一个列表的第一个元素，重复1的判断规则
											3》如果最终无法把所有元素归并到解析列表，则报错
								2】类似拓扑排序，但并不是！切记
							e、查看资源查找顺序：
								1】import inspect
								      inspect.getmro()
								2】类名.__mro__
								3】类名.mro()
				（3）资源的覆盖：
					1、包括：
						A、属性的覆盖
						B、方法重写
					2、原理：在MRO的资源检索链中，优先级比较高的类写了一个和优先级比较低的类一样的一个资源(属性或方法)，
						到时候，再去获取相关资源，就会优先选择优先级比较高的资源；而摈弃优先级比较低的资源；造成"覆盖"的假象
					3、注意事项：当调用优先级比较高的资源时，注意self的变化
				（4）资源的累加：
					1、概念：在一个类的基础上，增加一些额外的资源
					2、子类相比于父类，多一些自己特有的资源
					3、在被覆盖的方法基础上新增内容：
						A、方案1：
						B、方案2：在低优先级类的方法中，通过"super"调用高优先级类的方法：
							a、概念：是一个类；只在新式类中有效
							b、作用：起着代理的作用，帮我们完成：沿着MRO链条，找到下一级节点，去调用对应的方法
							c、问题：
								1】沿着谁的MRO链条？
								2】找谁的下一节点？
								3】如何应对类方法，静态方法以及实例方法的传参问题？
							d、语法原理：
								1】super(参数1[, 参数2])
								2】
									def super(cls, inst):
									    mro = inst.__class__mro()
									    return mro[mro.index(cls) + 1]
								3】问题解决：
									1）沿着谁的MRO链条：参数2
									2）找谁的下一节点：参数1
									3）如何应对类方法，静态方法以及实例方法的传参问题：使用参数2进行调用
							e、常用具体语法形式：
								1】super(type, obj) -> bound super object; Python2.2后可用
								2】super(type, type2) -> bound super object; Python2.2后可用
								3】super(); Python3后可用
							f、注意：
		{3}多态：
			[1]多态：
				（1）一个类所延伸的多种形态
				（2）调用时的多种形态
			[2]多态在Python中的体现：
				（1）鸭子类型：动态类型的一种风格，只要一个对象，会走，会游泳，会叫；那么它就可以放做一个鸭子进行处理；所以关注点在于对象的"行为和属性"；而非对象的"类型"
				（2）所以，在python中，没有真正意义上的多态；也不需要多态
		{4}补充：
			[1]抽象类：
				（1）一个抽象出来的类，并不是某一个具体化的类
				（2）不能直接创建实例的类：创建会报错
			[2]抽象方法：
				（1）抽象出来的一个方法
				（2）不具备具体实现，不能直接调用：子类不实现会报错
			[3]Python中的实现：
				（1）无法直接支持，需要借助一个模块：import abc
				（2）设置类的元类为：abc.ABCMeta
				（3）使用装饰器修饰抽象方法：@abc.abstractmethod
	六、三大特性-综合案例：
		{1}案例说明：
			[1]定义三个类：小猫，小狗，人
			[2]小狗：姓名，年龄(默认1岁)；吃饭，玩，睡觉，看家(格式：名字是xx，年龄是xx岁的小狗在xx)
			[3]小猫：姓名，年龄(默认1岁)；吃饭，玩，睡觉，捉老鼠(格式：名字是xx，年龄是xx岁的小猫在xx)
			[4]人：姓名，年龄(默认1岁)；   宠物；吃饭，玩，睡觉(格式：名字是xx，年龄是xx岁的人在xx)
					                养宠物(让所有的宠物吃饭，玩，睡觉)
					                让宠物工作(让所有的宠物根据自己的职责开始工作)
		{2}怎样通过代码，去解决问题：
			[1]有开发经验的：获得问题后，根据自己的开发经验，制定出一套自认为完美的解决方案，之后，通过代码实现这个方案
			[2]无开发经验的：
				（1）有进取心的：获得问题后，直接通过代码实现能够想到的问题，之后再检测发现代码问题，重构代码并不断地去升级方案
				（2）无进取心的：获得问题后，直接通过代码实现能够想到的问题
		{3}作业：
			[1]定义三个类：学生，组长，教师
			[2]学生：
				（1）姓名，年龄，学号
				（2）吃饭，睡觉，学习
			[3]组长：
				（1）姓名，年龄，学号，职务
				（2）吃饭，睡觉，学习，管理
			[4]教师：
				（1）姓名，年龄，职务
				（2）吃饭，睡觉，教学，管理
	七、常用设计模式：...
	八、经验补充：设计原则：
		{1}面向对象遵循的原则：SOLID
		{2}S(Single Responsibility Principle):
			[1]单一职责原则：一个类只负责一项职责
			[2]好处：易于维护，写出高内聚的代码；易于代码复用
			[3]案例：
				（1）我们之前写的计算机类：假设只包含加减乘除运算和结果打印；如果往后需要增加，结果写入文件，结果参与其他运算，结果上传服务器...
				         是不是每一次都需要去修改此类？就导致这个类变得非常臃肿；不利于维护和部分代码复用
				（2）解决方案：
					1、计算器只包，含加减乘除运算以及结果返回
					2、根据不同情况，将对结果的处理分散到其它合适的类别中
		{3}O(Open Closed Principle)：
			[1]开放封闭原则：
				（1）对扩展开发
				（2）对修改关闭
			[2]易于维护，保证代码安全性以及扩展性
			[3]案例：
				（1）我们之前写的，在Person类中，写的，让小猫小狗工作的方法：
					1、假设小猫小狗的工作方法分别是watch和catch：那Person类中让宠物工作的方法就需要通过if进行多分支判定
					2、如果以后，扩展了新的宠物类：那么Person类中的让宠物工作的方法，必须要跟着修改
				（2）解决方案：通过基类，以及抽象类等方案进行方法的统一：比如：代码篇中，将让宠物工作的方法统一成work名称
		{4}L(Liskov Substitution Principle)：
			[1]里氏替换原则：使用基类引用的地方必须能使用继承类的对象
			[2]好处：防止代码发生不可预知的错误；方便针对于基类的测试代码，可以复用在子类上
			[3]案例：
				     小鸟
				def fly(self):
				     pass
				       ^
				       |
			  ----------------
			  |		           |
			小燕子		         鸵鸟
		{5}I(Interface Segregation Principle)：
			[1]接口分离原则：
				（1）如果一个类包含了过多的接口方法，而这些方法在使用的过程中并非"不可分割"，那么应当把他们进行分离
				（2）所谓接口，在Python中，可以简单的理解为"抽象方法"
			[2]好处：提高接口的重用价值
			[3]案例：
				（1）小鸟：吃，叫，飞
				（2）上述接口设计在有鸵鸟类(不会飞)的前提下，设计就不合理，应当将吃和叫归为一个公共的类里
		{6}D(Dependency Inversion Principle)：
			[1]依赖倒置原则：高层模块不应该直接依赖低层模块，它们应该依赖抽象类或者接口
			[2]好处：利于代码维护
			[3]案例：电脑类，依赖的不是某一个具体的鼠标类，而应该是，鼠标类的抽象：能单击，能双击，能右击，能移动鼠标指针...到时，可以是触摸板，也可以是有线鼠标，也可以是蓝牙鼠标...
